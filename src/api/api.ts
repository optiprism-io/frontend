/* tslint:disable */
/* eslint-disable */
/**
 * OptiPrism
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@optiprism.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'role'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Account
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<AccountProjectsInner>}
     * @memberof Account
     */
    'projects'?: Array<AccountProjectsInner>;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface AccountProjectsInner
 */
export interface AccountProjectsInner {
    /**
     * 
     * @type {number}
     * @memberof AccountProjectsInner
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountProjectsInner
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface AnalysisCumulative
 */
export interface AnalysisCumulative {
    /**
     * 
     * @type {string}
     * @memberof AnalysisCumulative
     */
    'type': AnalysisCumulativeTypeEnum;
}

export const AnalysisCumulativeTypeEnum = {
    Cumulative: 'cumulative'
} as const;

export type AnalysisCumulativeTypeEnum = typeof AnalysisCumulativeTypeEnum[keyof typeof AnalysisCumulativeTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisLinear
 */
export interface AnalysisLinear {
    /**
     * 
     * @type {string}
     * @memberof AnalysisLinear
     */
    'type': AnalysisLinearTypeEnum;
}

export const AnalysisLinearTypeEnum = {
    Linear: 'linear'
} as const;

export type AnalysisLinearTypeEnum = typeof AnalysisLinearTypeEnum[keyof typeof AnalysisLinearTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisLogarithmic
 */
export interface AnalysisLogarithmic {
    /**
     * 
     * @type {string}
     * @memberof AnalysisLogarithmic
     */
    'type': AnalysisLogarithmicTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisLogarithmic
     */
    'window'?: number;
}

export const AnalysisLogarithmicTypeEnum = {
    Logarithmic: 'logarithmic'
} as const;

export type AnalysisLogarithmicTypeEnum = typeof AnalysisLogarithmicTypeEnum[keyof typeof AnalysisLogarithmicTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingAverage
 */
export interface AnalysisRollingAverage {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingAverage
     */
    'type': AnalysisRollingAverageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingAverage
     */
    'window': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof AnalysisRollingAverage
     */
    'unit': TimeUnit;
}

export const AnalysisRollingAverageTypeEnum = {
    RollingAverage: 'rollingAverage'
} as const;

export type AnalysisRollingAverageTypeEnum = typeof AnalysisRollingAverageTypeEnum[keyof typeof AnalysisRollingAverageTypeEnum];

/**
 * breakdown by property.
 * @export
 * @interface BreakdownByProperty
 */
export interface BreakdownByProperty {
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof BreakdownByProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof BreakdownByProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'type': BreakdownByPropertyTypeEnum;
}

export const BreakdownByPropertyTypeEnum = {
    Property: 'property'
} as const;

export type BreakdownByPropertyTypeEnum = typeof BreakdownByPropertyTypeEnum[keyof typeof BreakdownByPropertyTypeEnum];

/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties. 
 * @export
 * @interface CreateCustomEventRequest
 */
export interface CreateCustomEventRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCustomEventRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CreateCustomEventRequest
     */
    'events': Array<CustomEventEvent>;
}
/**
 * 
 * @export
 * @interface CreateDashboardRequest
 */
export interface CreateDashboardRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateDashboardRequest
     */
    'tags'?: Array<string>;
    /**
     * dashboard name
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    'name': string;
    /**
     * description
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DashboardPanel>}
     * @memberof CreateDashboardRequest
     */
    'panels'?: Array<DashboardPanel>;
}
/**
 * 
 * @export
 * @interface CreateProjectRequest
 */
export interface CreateProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateProjectRequest
     */
    'sessionDurationSeconds': number;
}
/**
 * 
 * @export
 * @interface CreateReportRequest
 */
export interface CreateReportRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateReportRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateReportRequest
     */
    'name': string;
    /**
     * description
     * @type {string}
     * @memberof CreateReportRequest
     */
    'description'?: string;
    /**
     * 
     * @type {ReportType}
     * @memberof CreateReportRequest
     */
    'type': ReportType;
    /**
     * 
     * @type {ReportQuery}
     * @memberof CreateReportRequest
     */
    'query': ReportQuery;
}


/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties. 
 * @export
 * @interface CustomEvent
 */
export interface CustomEvent {
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'createdBy': number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'projectId': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomEvent
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'description'?: string;
    /**
     * 
     * @type {CustomEventStatus}
     * @memberof CustomEvent
     */
    'status': CustomEventStatus;
    /**
     * 
     * @type {boolean}
     * @memberof CustomEvent
     */
    'isSystem': boolean;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CustomEvent
     */
    'events': Array<CustomEventEvent>;
}


/**
 * custom event will matches all of the provided events
 * @export
 * @interface CustomEventEvent
 */
export interface CustomEventEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomEventEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomEventEvent
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof CustomEventEvent
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEvent
     */
    'filters'?: Array<EventFilterByProperty>;
}


/**
 * custom event status
 * @export
 * @enum {string}
 */

export const CustomEventStatus = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomEventStatus = typeof CustomEventStatus[keyof typeof CustomEventStatus];


/**
 * 
 * @export
 * @interface CustomEventsList200Response
 */
export interface CustomEventsList200Response {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof CustomEventsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
    /**
     * 
     * @type {Array<CustomEvent>}
     * @memberof CustomEventsList200Response
     */
    'data'?: Array<CustomEvent>;
}
/**
 * 
 * @export
 * @interface CustomPropertiesList200Response
 */
export interface CustomPropertiesList200Response {
    /**
     * 
     * @type {Array<CustomProperty>}
     * @memberof CustomPropertiesList200Response
     */
    'events'?: Array<CustomProperty>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof CustomPropertiesList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'projectId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomProperty
     */
    'events'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isSystem'?: boolean;
    /**
     * 
     * @type {CustomPropertyStatus}
     * @memberof CustomProperty
     */
    'status'?: CustomPropertyStatus;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'description'?: string;
    /**
     * 
     * @type {DataType}
     * @memberof CustomProperty
     */
    'type'?: DataType;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isArray'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    'tags'?: Array<string>;
}


/**
 * custom property status
 * @export
 * @enum {string}
 */

export const CustomPropertyStatus = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomPropertyStatus = typeof CustomPropertyStatus[keyof typeof CustomPropertyStatus];


/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * dashboard unique id
     * @type {number}
     * @memberof Dashboard
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Dashboard
     */
    'createdAt'?: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Dashboard
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Dashboard
     */
    'createdBy'?: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Dashboard
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Dashboard
     */
    'projectId'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Dashboard
     */
    'tags'?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Dashboard
     */
    'name': string;
    /**
     * description
     * @type {string}
     * @memberof Dashboard
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DashboardPanel>}
     * @memberof Dashboard
     */
    'panels'?: Array<DashboardPanel>;
}
/**
 * 
 * @export
 * @interface DashboardPanel
 */
export interface DashboardPanel {
    /**
     * 
     * @type {string}
     * @memberof DashboardPanel
     */
    'type': DashboardPanelTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DashboardPanel
     */
    'reportId': number;
    /**
     * x
     * @type {number}
     * @memberof DashboardPanel
     */
    'x': number;
    /**
     * y
     * @type {number}
     * @memberof DashboardPanel
     */
    'y': number;
    /**
     * width
     * @type {number}
     * @memberof DashboardPanel
     */
    'w': number;
    /**
     * height
     * @type {number}
     * @memberof DashboardPanel
     */
    'h': number;
}

export const DashboardPanelTypeEnum = {
    Report: 'report'
} as const;

export type DashboardPanelTypeEnum = typeof DashboardPanelTypeEnum[keyof typeof DashboardPanelTypeEnum];

/**
 * 
 * @export
 * @interface DashboardsList200Response
 */
export interface DashboardsList200Response {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof DashboardsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
    /**
     * 
     * @type {Array<Dashboard>}
     * @memberof DashboardsList200Response
     */
    'data'?: Array<Dashboard>;
}
/**
 * 
 * @export
 * @interface DataTableResponse
 */
export interface DataTableResponse {
    /**
     * 
     * @type {Array<DataTableResponseColumnsInner>}
     * @memberof DataTableResponse
     */
    'columns'?: Array<DataTableResponseColumnsInner>;
}
/**
 * 
 * @export
 * @interface DataTableResponseColumnsInner
 */
export interface DataTableResponseColumnsInner {
    /**
     * 
     * @type {string}
     * @memberof DataTableResponseColumnsInner
     */
    'type': DataTableResponseColumnsInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DataTableResponseColumnsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof DataTableResponseColumnsInner
     */
    'isNullable': boolean;
    /**
     * 
     * @type {DataType}
     * @memberof DataTableResponseColumnsInner
     */
    'dataType': DataType;
    /**
     * 
     * @type {DataTableResponseColumnsInnerData}
     * @memberof DataTableResponseColumnsInner
     */
    'data': DataTableResponseColumnsInnerData;
    /**
     * 
     * @type {number}
     * @memberof DataTableResponseColumnsInner
     */
    'step'?: number;
    /**
     * 
     * @type {DataTableResponseColumnsInnerData}
     * @memberof DataTableResponseColumnsInner
     */
    'compareValues'?: DataTableResponseColumnsInnerData;
}

export const DataTableResponseColumnsInnerTypeEnum = {
    Dimension: 'dimension',
    Metric: 'metric',
    MetricValue: 'metricValue',
    FunnelMetricValue: 'funnelMetricValue'
} as const;

export type DataTableResponseColumnsInnerTypeEnum = typeof DataTableResponseColumnsInnerTypeEnum[keyof typeof DataTableResponseColumnsInnerTypeEnum];

/**
 * @type DataTableResponseColumnsInnerData
 * @export
 */
export type DataTableResponseColumnsInnerData = Array<boolean> | Array<number> | Array<string>;

/**
 * data type
 * @export
 * @enum {string}
 */

export const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean'
} as const;

export type DataType = typeof DataType[keyof typeof DataType];


/**
 * dictionary data type
 * @export
 * @enum {string}
 */

export const DictionaryDataType = {
    Uint8: 'uint8',
    Uint16: 'uint16',
    Uint32: 'uint32',
    Uint64: 'uint64'
} as const;

export type DictionaryDataType = typeof DictionaryDataType[keyof typeof DictionaryDataType];


/**
 * aggregate property and compare to value
 * @export
 * @interface DidEventAggregateProperty
 */
export interface DidEventAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof DidEventAggregateProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'type': DidEventAggregatePropertyTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof DidEventAggregateProperty
     */
    'aggregate': QueryAggregate;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregateProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {Value}
     * @memberof DidEventAggregateProperty
     */
    'value'?: Value;
    /**
     * 
     * @type {DidEventAggregatePropertyAllOfTime}
     * @memberof DidEventAggregateProperty
     */
    'time': DidEventAggregatePropertyAllOfTime;
}

export const DidEventAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyTypeEnum = typeof DidEventAggregatePropertyTypeEnum[keyof typeof DidEventAggregatePropertyTypeEnum];

/**
 * @type DidEventAggregatePropertyAllOfTime
 * time frame
 * @export
 */
export type DidEventAggregatePropertyAllOfTime = TimeAfterFirstUse | TimeBetween | TimeLast | TimeWindowEach;

/**
 * find all users who made event X times
 * @export
 * @interface DidEventCount
 */
export interface DidEventCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventCount
     */
    'type': DidEventCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventCount
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventCount
     */
    'value': number;
    /**
     * 
     * @type {DidEventCountTime}
     * @memberof DidEventCount
     */
    'time': DidEventCountTime;
}

export const DidEventCountTypeEnum = {
    Count: 'count'
} as const;

export type DidEventCountTypeEnum = typeof DidEventCountTypeEnum[keyof typeof DidEventCountTypeEnum];

/**
 * @type DidEventCountTime
 * time frame
 * @export
 */
export type DidEventCountTime = TimeAfterFirstUse | TimeBetween | TimeLast | TimeWindowEach;

/**
 * find users with Nth event occurance
 * @export
 * @interface DidEventHistoricalCount
 */
export interface DidEventHistoricalCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventHistoricalCount
     */
    'type': DidEventHistoricalCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventHistoricalCount
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {number}
     * @memberof DidEventHistoricalCount
     */
    'value'?: number;
    /**
     * 
     * @type {DidEventRelativeCountAllOfTime}
     * @memberof DidEventHistoricalCount
     */
    'time': DidEventRelativeCountAllOfTime;
}

export const DidEventHistoricalCountTypeEnum = {
    HistoricalCount: 'historicalCount'
} as const;

export type DidEventHistoricalCountTypeEnum = typeof DidEventHistoricalCountTypeEnum[keyof typeof DidEventHistoricalCountTypeEnum];

/**
 * find all users who made left event X time more/less than right event.
 * @export
 * @interface DidEventRelativeCount
 */
export interface DidEventRelativeCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventRelativeCount
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DidEventRelativeCount
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof DidEventRelativeCount
     */
    'eventType': EventType;
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof DidEventRelativeCount
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {string}
     * @memberof DidEventRelativeCount
     */
    'type': DidEventRelativeCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventRelativeCount
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {DidEventRelativeCountAllOfTime}
     * @memberof DidEventRelativeCount
     */
    'time': DidEventRelativeCountAllOfTime;
}

export const DidEventRelativeCountTypeEnum = {
    RelativeCount: 'relativeCount'
} as const;

export type DidEventRelativeCountTypeEnum = typeof DidEventRelativeCountTypeEnum[keyof typeof DidEventRelativeCountTypeEnum];

/**
 * @type DidEventRelativeCountAllOfTime
 * @export
 */
export type DidEventRelativeCountAllOfTime = TimeAfterFirstUse | TimeBetween | TimeLast | TimeWindowEach;

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof ErrorResponse
     */
    'error'?: ErrorResponseError;
}
/**
 * 
 * @export
 * @interface ErrorResponseError
 */
export interface ErrorResponseError {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseError
     */
    'code'?: ErrorResponseErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseError
     */
    'message'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ErrorResponseError
     */
    'fields'?: { [key: string]: string; };
}

export const ErrorResponseErrorCodeEnum = {
    _1000InvalidToken: '1000_invalid_token'
} as const;

export type ErrorResponseErrorCodeEnum = typeof ErrorResponseErrorCodeEnum[keyof typeof ErrorResponseErrorCodeEnum];

/**
 * Event describes user event. User event is an action which user (client) might do on a product site/app. For instance, user might do a signup and it might be a \"Sign up\" event. Event Also has a properties. <br/><br/> Name must be unique among project events, including custom ones. E.g. you can\'t have multiple \"Sign up\" events. <br/><br/> Normally events are created and updated by admin in a project scope, but there are also system events, which can\'t be deleted or modified. 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * event unique id
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Event
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Event
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Event
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Event
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Event
     */
    'projectId': number;
    /**
     * the event is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Event
     */
    'isSystem': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'tags'?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof Event
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof Event
     */
    'status': EventStatus;
    /**
     * array of id of attached to event properties
     * @type {Array<number>}
     * @memberof Event
     */
    'eventProperties'?: Array<number>;
    /**
     * array of id of attached to user properties
     * @type {Array<number>}
     * @memberof Event
     */
    'userProperties'?: Array<number>;
}


/**
 * chart type
 * @export
 * @enum {string}
 */

export const EventChartType = {
    Line: 'line',
    Bar: 'bar',
    SingleValue: 'singleValue'
} as const;

export type EventChartType = typeof EventChartType[keyof typeof EventChartType];


/**
 * 
 * @export
 * @interface EventFilterByCohort
 */
export interface EventFilterByCohort {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByCohort
     */
    'type': EventFilterByCohortTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByCohort
     */
    'cohortId': number;
}

export const EventFilterByCohortTypeEnum = {
    Cohort: 'cohort'
} as const;

export type EventFilterByCohortTypeEnum = typeof EventFilterByCohortTypeEnum[keyof typeof EventFilterByCohortTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByGroup
 */
export interface EventFilterByGroup {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByGroup
     */
    'type': EventFilterByGroupTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByGroup
     */
    'groupId': number;
}

export const EventFilterByGroupTypeEnum = {
    Group: 'group'
} as const;

export type EventFilterByGroupTypeEnum = typeof EventFilterByGroupTypeEnum[keyof typeof EventFilterByGroupTypeEnum];

/**
 * filter by property
 * @export
 * @interface EventFilterByProperty
 */
export interface EventFilterByProperty {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof EventFilterByProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'type': EventFilterByPropertyTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByProperty
     */
    'value'?: Array<Value>;
}

export const EventFilterByPropertyTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyTypeEnum = typeof EventFilterByPropertyTypeEnum[keyof typeof EventFilterByPropertyTypeEnum];

/**
 * event filters
 * @export
 * @interface EventGroupedFilters
 */
export interface EventGroupedFilters {
    /**
     * 
     * @type {string}
     * @memberof EventGroupedFilters
     */
    'groupsCondition'?: EventGroupedFiltersGroupsConditionEnum;
    /**
     * 
     * @type {Array<EventGroupedFiltersGroupsInner>}
     * @memberof EventGroupedFilters
     */
    'groups': Array<EventGroupedFiltersGroupsInner>;
}

export const EventGroupedFiltersGroupsConditionEnum = {
    And: 'and',
    Or: 'or'
} as const;

export type EventGroupedFiltersGroupsConditionEnum = typeof EventGroupedFiltersGroupsConditionEnum[keyof typeof EventGroupedFiltersGroupsConditionEnum];

/**
 * 
 * @export
 * @interface EventGroupedFiltersGroupsInner
 */
export interface EventGroupedFiltersGroupsInner {
    /**
     * 
     * @type {string}
     * @memberof EventGroupedFiltersGroupsInner
     */
    'filtersCondition'?: EventGroupedFiltersGroupsInnerFiltersConditionEnum;
    /**
     * 
     * @type {Array<EventGroupedFiltersGroupsInnerFiltersInner>}
     * @memberof EventGroupedFiltersGroupsInner
     */
    'filters': Array<EventGroupedFiltersGroupsInnerFiltersInner>;
}

export const EventGroupedFiltersGroupsInnerFiltersConditionEnum = {
    And: 'and',
    Or: 'or'
} as const;

export type EventGroupedFiltersGroupsInnerFiltersConditionEnum = typeof EventGroupedFiltersGroupsInnerFiltersConditionEnum[keyof typeof EventGroupedFiltersGroupsInnerFiltersConditionEnum];

/**
 * 
 * @export
 * @interface EventGroupedFiltersGroupsInnerFiltersInner
 */
export interface EventGroupedFiltersGroupsInnerFiltersInner {
    /**
     * 
     * @type {string}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'type': EventGroupedFiltersGroupsInnerFiltersInnerTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'cohortId': number;
    /**
     * 
     * @type {string}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'value'?: Array<Value>;
    /**
     * 
     * @type {number}
     * @memberof EventGroupedFiltersGroupsInnerFiltersInner
     */
    'groupId': number;
}

export const EventGroupedFiltersGroupsInnerFiltersInnerTypeEnum = {
    Cohort: 'cohort',
    Property: 'property',
    Group: 'group'
} as const;

export type EventGroupedFiltersGroupsInnerFiltersInnerTypeEnum = typeof EventGroupedFiltersGroupsInnerFiltersInnerTypeEnum[keyof typeof EventGroupedFiltersGroupsInnerFiltersInnerTypeEnum];

/**
 * 
 * @export
 * @interface EventRecord
 */
export interface EventRecord {
    /**
     * 
     * @type {number}
     * @memberof EventRecord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EventRecord
     */
    'name': string;
    /**
     * map of property name and property value pairs
     * @type {{ [key: string]: Value; }}
     * @memberof EventRecord
     */
    'eventProperties'?: { [key: string]: Value; };
    /**
     * map of user name and property value pairs
     * @type {{ [key: string]: Value; }}
     * @memberof EventRecord
     */
    'userProperties'?: { [key: string]: Value; };
    /**
     * 
     * @type {Array<EventRecordMatchedCustomEventsInner>}
     * @memberof EventRecord
     */
    'matchedCustomEvents'?: Array<EventRecordMatchedCustomEventsInner>;
}
/**
 * 
 * @export
 * @interface EventRecordMatchedCustomEventsInner
 */
export interface EventRecordMatchedCustomEventsInner {
    /**
     * 
     * @type {number}
     * @memberof EventRecordMatchedCustomEventsInner
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface EventRecordRequestEvent
 */
export interface EventRecordRequestEvent {
    /**
     * 
     * @type {string}
     * @memberof EventRecordRequestEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventRecordRequestEvent
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof EventRecordRequestEvent
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<EventRecordRequestEventFiltersFiltersInner>}
     * @memberof EventRecordRequestEvent
     */
    'filters'?: Array<EventRecordRequestEventFiltersFiltersInner>;
}


/**
 * @type EventRecordRequestEventFiltersFiltersInner
 * @export
 */
export type EventRecordRequestEventFiltersFiltersInner = EventFilterByGroup | EventFilterByProperty;

/**
 * request event records sorted by time of creation
 * @export
 * @interface EventRecordsListRequest
 */
export interface EventRecordsListRequest {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof EventRecordsListRequest
     */
    'time': EventRecordsListRequestTime;
    /**
     * 
     * @type {Array<Value>}
     * @memberof EventRecordsListRequest
     */
    'searchInEventProperties'?: Array<Value>;
    /**
     * 
     * @type {Array<Value>}
     * @memberof EventRecordsListRequest
     */
    'searchInUserProperties'?: Array<Value>;
    /**
     * array of events to query
     * @type {Array<EventRecordRequestEvent>}
     * @memberof EventRecordsListRequest
     */
    'events'?: Array<EventRecordRequestEvent>;
    /**
     * 
     * @type {EventGroupedFilters}
     * @memberof EventRecordsListRequest
     */
    'filters'?: EventGroupedFilters;
}
/**
 * @type EventRecordsListRequestTime
 * select time
 * @export
 */
export type EventRecordsListRequestTime = TimeBetween | TimeFrom | TimeLast;

/**
 * reference to event by its name and type
 * @export
 * @interface EventRef
 */
export interface EventRef {
    /**
     * 
     * @type {string}
     * @memberof EventRef
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventRef
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof EventRef
     */
    'eventType': EventType;
}


/**
 * event segmentation report type main payload
 * @export
 * @interface EventSegmentation
 */
export interface EventSegmentation {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof EventSegmentation
     */
    'time': EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof EventSegmentation
     */
    'group': string;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentation
     */
    'intervalUnit': TimeUnit;
    /**
     * 
     * @type {EventChartType}
     * @memberof EventSegmentation
     */
    'chartType': EventChartType;
    /**
     * 
     * @type {EventSegmentationAnalysis}
     * @memberof EventSegmentation
     */
    'analysis': EventSegmentationAnalysis;
    /**
     * 
     * @type {EventSegmentationCompare}
     * @memberof EventSegmentation
     */
    'compare'?: EventSegmentationCompare;
    /**
     * array of events to query
     * @type {Array<EventSegmentationEvent>}
     * @memberof EventSegmentation
     */
    'events': Array<EventSegmentationEvent>;
    /**
     * 
     * @type {EventGroupedFilters}
     * @memberof EventSegmentation
     */
    'filters'?: EventGroupedFilters;
    /**
     * array of common breakdowns (which applies to all events)
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentation
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof EventSegmentation
     */
    'segments'?: Array<EventSegmentationSegment>;
}


/**
 * @type EventSegmentationAnalysis
 * analysis type
 * @export
 */
export type EventSegmentationAnalysis = AnalysisCumulative | AnalysisLinear | AnalysisRollingAverage;

/**
 * optional comparison with previous period
 * @export
 * @interface EventSegmentationCompare
 */
export interface EventSegmentationCompare {
    /**
     * offset in past in timeUnit
     * @type {number}
     * @memberof EventSegmentationCompare
     */
    'offset': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentationCompare
     */
    'unit': TimeUnit;
}


/**
 * event object
 * @export
 * @interface EventSegmentationEvent
 */
export interface EventSegmentationEvent {
    /**
     * 
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventSegmentationEvent
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof EventSegmentationEvent
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<EventSegmentationEventAllOfFilters>}
     * @memberof EventSegmentationEvent
     */
    'filters'?: Array<EventSegmentationEventAllOfFilters>;
    /**
     * 
     * @type {Array<EventSegmentationEventAllOfBreakdowns>}
     * @memberof EventSegmentationEvent
     */
    'breakdowns'?: Array<EventSegmentationEventAllOfBreakdowns>;
    /**
     * array of event queries
     * @type {Array<EventSegmentationEventAllOfQueries>}
     * @memberof EventSegmentationEvent
     */
    'queries': Array<EventSegmentationEventAllOfQueries>;
}


/**
 * @type EventSegmentationEventAllOfBreakdowns
 * array of event breakdowns
 * @export
 */
export type EventSegmentationEventAllOfBreakdowns = BreakdownByProperty;

/**
 * @type EventSegmentationEventAllOfFilters
 * @export
 */
export type EventSegmentationEventAllOfFilters = EventFilterByProperty;

/**
 * @type EventSegmentationEventAllOfQueries
 * @export
 */
export type EventSegmentationEventAllOfQueries = QueryAggregateProperty | QueryAggregatePropertyPerGroup | QueryCountPerGroup | QueryFormula | QuerySimple;

/**
 * segment
 * @export
 * @interface EventSegmentationSegment
 */
export interface EventSegmentationSegment {
    /**
     * name of segment
     * @type {string}
     * @memberof EventSegmentationSegment
     */
    'name'?: string;
    /**
     * array of conditions
     * @type {Array<EventSegmentationSegmentConditionsInner>}
     * @memberof EventSegmentationSegment
     */
    'conditions': Array<EventSegmentationSegmentConditionsInner>;
}
/**
 * @type EventSegmentationSegmentConditionsInner
 * @export
 */
export type EventSegmentationSegmentConditionsInner = SegmentConditionDidEvent | SegmentConditionFunnel | SegmentConditionHadPropertyValue | SegmentConditionHasPropertyValue;

/**
 * event status
 * @export
 * @enum {string}
 */

export const EventStatus = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type EventStatus = typeof EventStatus[keyof typeof EventStatus];


/**
 * possible event type
 * @export
 * @enum {string}
 */

export const EventType = {
    Regular: 'regular',
    Custom: 'custom'
} as const;

export type EventType = typeof EventType[keyof typeof EventType];


/**
 * 
 * @export
 * @interface EventsList200Response
 */
export interface EventsList200Response {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof EventsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventsList200Response
     */
    'data'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface FunnelConversionOverTimeChartType
 */
export interface FunnelConversionOverTimeChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelConversionOverTimeChartType
     */
    'type': FunnelConversionOverTimeChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelConversionOverTimeChartType
     */
    'intervalUnit': TimeUnit;
}

export const FunnelConversionOverTimeChartTypeTypeEnum = {
    ConversionOverTime: 'conversionOverTime'
} as const;

export type FunnelConversionOverTimeChartTypeTypeEnum = typeof FunnelConversionOverTimeChartTypeTypeEnum[keyof typeof FunnelConversionOverTimeChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelConversionStepsChartType
 */
export interface FunnelConversionStepsChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelConversionStepsChartType
     */
    'type': FunnelConversionStepsChartTypeTypeEnum;
}

export const FunnelConversionStepsChartTypeTypeEnum = {
    ConversionSteps: 'conversionSteps'
} as const;

export type FunnelConversionStepsChartTypeTypeEnum = typeof FunnelConversionStepsChartTypeTypeEnum[keyof typeof FunnelConversionStepsChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelConversionStepsChartTypeResponse
 */
export interface FunnelConversionStepsChartTypeResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'dimensionHeaders'?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'dimensions'?: Array<Array<string>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'metrics'?: Array<FunnelConversionStepsChartTypeResponseMetricsEnum>;
    /**
     * 
     * @type {Array<number>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'singles'?: Array<number>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'series'?: Array<Array<number>>;
}

export const FunnelConversionStepsChartTypeResponseMetricsEnum = {
    AvgTimeToConvert: 'avgTimeToConvert'
} as const;

export type FunnelConversionStepsChartTypeResponseMetricsEnum = typeof FunnelConversionStepsChartTypeResponseMetricsEnum[keyof typeof FunnelConversionStepsChartTypeResponseMetricsEnum];

/**
 * event object
 * @export
 * @interface FunnelEvent
 */
export interface FunnelEvent {
    /**
     * 
     * @type {string}
     * @memberof FunnelEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof FunnelEvent
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof FunnelEvent
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<FunnelEventAllOfFilters>}
     * @memberof FunnelEvent
     */
    'filters': Array<FunnelEventAllOfFilters>;
}


/**
 * @type FunnelEventAllOfFilters
 * @export
 */
export type FunnelEventAllOfFilters = EventFilterByProperty;

/**
 * 
 * @export
 * @interface FunnelExcludeSteps
 */
export interface FunnelExcludeSteps {
    /**
     * 
     * @type {FunnelExcludeStepsSteps}
     * @memberof FunnelExcludeSteps
     */
    'steps': FunnelExcludeStepsSteps;
}
/**
 * @type FunnelExcludeStepsSteps
 * @export
 */
export type FunnelExcludeStepsSteps = FunnelExcludeStepsStepsOneOf | FunnelExcludeStepsStepsOneOf1;

/**
 * 
 * @export
 * @interface FunnelExcludeStepsStepsOneOf
 */
export interface FunnelExcludeStepsStepsOneOf {
    /**
     * 
     * @type {string}
     * @memberof FunnelExcludeStepsStepsOneOf
     */
    'type'?: FunnelExcludeStepsStepsOneOfTypeEnum;
}

export const FunnelExcludeStepsStepsOneOfTypeEnum = {
    All: 'all'
} as const;

export type FunnelExcludeStepsStepsOneOfTypeEnum = typeof FunnelExcludeStepsStepsOneOfTypeEnum[keyof typeof FunnelExcludeStepsStepsOneOfTypeEnum];

/**
 * 
 * @export
 * @interface FunnelExcludeStepsStepsOneOf1
 */
export interface FunnelExcludeStepsStepsOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof FunnelExcludeStepsStepsOneOf1
     */
    'type': FunnelExcludeStepsStepsOneOf1TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelExcludeStepsStepsOneOf1
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof FunnelExcludeStepsStepsOneOf1
     */
    'to': number;
}

export const FunnelExcludeStepsStepsOneOf1TypeEnum = {
    Between: 'between'
} as const;

export type FunnelExcludeStepsStepsOneOf1TypeEnum = typeof FunnelExcludeStepsStepsOneOf1TypeEnum[keyof typeof FunnelExcludeStepsStepsOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface FunnelFrequencyChartType
 */
export interface FunnelFrequencyChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelFrequencyChartType
     */
    'type': FunnelFrequencyChartTypeTypeEnum;
}

export const FunnelFrequencyChartTypeTypeEnum = {
    Frequency: 'frequency'
} as const;

export type FunnelFrequencyChartTypeTypeEnum = typeof FunnelFrequencyChartTypeTypeEnum[keyof typeof FunnelFrequencyChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQuery
 */
export interface FunnelQuery {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof FunnelQuery
     */
    'time': EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof FunnelQuery
     */
    'group': string;
    /**
     * 
     * @type {Array<FunnelQueryStepsInner>}
     * @memberof FunnelQuery
     */
    'steps': Array<FunnelQueryStepsInner>;
    /**
     * 
     * @type {FunnelQueryTimeWindow}
     * @memberof FunnelQuery
     */
    'timeWindow': FunnelQueryTimeWindow;
    /**
     * 
     * @type {FunnelQueryChartType}
     * @memberof FunnelQuery
     */
    'chartType': FunnelQueryChartType;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuery
     */
    'count': FunnelQueryCountEnum;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuery
     */
    'stepOrder': FunnelQueryStepOrderEnum;
    /**
     * 
     * @type {FunnelQueryAttribution}
     * @memberof FunnelQuery
     */
    'attribution'?: FunnelQueryAttribution;
    /**
     * 
     * @type {Array<PropertyRef>}
     * @memberof FunnelQuery
     */
    'holdingConstants'?: Array<PropertyRef>;
    /**
     * 
     * @type {Array<FunnelQueryExcludeInner>}
     * @memberof FunnelQuery
     */
    'exclude'?: Array<FunnelQueryExcludeInner>;
    /**
     * array of breakdowns
     * @type {Array<BreakdownByProperty>}
     * @memberof FunnelQuery
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof FunnelQuery
     */
    'segments'?: Array<EventSegmentationSegment>;
    /**
     * 
     * @type {EventGroupedFilters}
     * @memberof FunnelQuery
     */
    'filters'?: EventGroupedFilters;
}

export const FunnelQueryCountEnum = {
    Uniques: 'uniques',
    Totals: 'totals'
} as const;

export type FunnelQueryCountEnum = typeof FunnelQueryCountEnum[keyof typeof FunnelQueryCountEnum];
export const FunnelQueryStepOrderEnum = {
    Any: 'any',
    ExactSequence: 'exactSequence',
    ExactOrder: 'exactOrder'
} as const;

export type FunnelQueryStepOrderEnum = typeof FunnelQueryStepOrderEnum[keyof typeof FunnelQueryStepOrderEnum];

/**
 * @type FunnelQueryAttribution
 * @export
 */
export type FunnelQueryAttribution = FunnelQueryAttributionOneOf | FunnelQueryAttributionOneOf1;

/**
 * 
 * @export
 * @interface FunnelQueryAttributionOneOf
 */
export interface FunnelQueryAttributionOneOf {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryAttributionOneOf
     */
    'type': FunnelQueryAttributionOneOfTypeEnum;
}

export const FunnelQueryAttributionOneOfTypeEnum = {
    FirstTouch: 'firstTouch',
    LastTouch: 'lastTouch'
} as const;

export type FunnelQueryAttributionOneOfTypeEnum = typeof FunnelQueryAttributionOneOfTypeEnum[keyof typeof FunnelQueryAttributionOneOfTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryAttributionOneOf1
 */
export interface FunnelQueryAttributionOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryAttributionOneOf1
     */
    'type': FunnelQueryAttributionOneOf1TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryAttributionOneOf1
     */
    'step': number;
}

export const FunnelQueryAttributionOneOf1TypeEnum = {
    Step: 'step'
} as const;

export type FunnelQueryAttributionOneOf1TypeEnum = typeof FunnelQueryAttributionOneOf1TypeEnum[keyof typeof FunnelQueryAttributionOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryChartType
 */
export interface FunnelQueryChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryChartType
     */
    'type': FunnelQueryChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelQueryChartType
     */
    'intervalUnit': TimeUnit;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryChartType
     */
    'minInterval'?: number;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryChartType
     */
    'maxInterval'?: number;
}

export const FunnelQueryChartTypeTypeEnum = {
    ConversionSteps: 'conversionSteps',
    ConversionOverTime: 'conversionOverTime',
    TimeToConvert: 'timeToConvert',
    Frequency: 'frequency'
} as const;

export type FunnelQueryChartTypeTypeEnum = typeof FunnelQueryChartTypeTypeEnum[keyof typeof FunnelQueryChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryExcludeInner
 */
export interface FunnelQueryExcludeInner {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryExcludeInner
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryExcludeInner
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof FunnelQueryExcludeInner
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<FunnelEventAllOfFilters>}
     * @memberof FunnelQueryExcludeInner
     */
    'filters': Array<FunnelEventAllOfFilters>;
    /**
     * 
     * @type {FunnelExcludeStepsSteps}
     * @memberof FunnelQueryExcludeInner
     */
    'steps': FunnelExcludeStepsSteps;
}


/**
 * 
 * @export
 * @interface FunnelQueryStepsInner
 */
export interface FunnelQueryStepsInner {
    /**
     * 
     * @type {Array<FunnelEvent>}
     * @memberof FunnelQueryStepsInner
     */
    'events': Array<FunnelEvent>;
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryStepsInner
     */
    'order'?: FunnelQueryStepsInnerOrderEnum;
}

export const FunnelQueryStepsInnerOrderEnum = {
    Any: 'any',
    Exact: 'exact'
} as const;

export type FunnelQueryStepsInnerOrderEnum = typeof FunnelQueryStepsInnerOrderEnum[keyof typeof FunnelQueryStepsInnerOrderEnum];

/**
 * 
 * @export
 * @interface FunnelQueryTimeWindow
 */
export interface FunnelQueryTimeWindow {
    /**
     * N days/weeks
     * @type {number}
     * @memberof FunnelQueryTimeWindow
     */
    'n': number;
    /**
     * 
     * @type {TimeUnitWithSession}
     * @memberof FunnelQueryTimeWindow
     */
    'unit': TimeUnitWithSession;
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryTimeWindow
     */
    'from'?: FunnelQueryTimeWindowFromEnum;
}

export const FunnelQueryTimeWindowFromEnum = {
    AnyDay: 'anyDay',
    FirstDay: 'firstDay'
} as const;

export type FunnelQueryTimeWindowFromEnum = typeof FunnelQueryTimeWindowFromEnum[keyof typeof FunnelQueryTimeWindowFromEnum];

/**
 * 
 * @export
 * @interface FunnelTimeToConvertChartType
 */
export interface FunnelTimeToConvertChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelTimeToConvertChartType
     */
    'type': FunnelTimeToConvertChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelTimeToConvertChartType
     */
    'intervalUnit': TimeUnit;
    /**
     * 
     * @type {number}
     * @memberof FunnelTimeToConvertChartType
     */
    'minInterval'?: number;
    /**
     * 
     * @type {number}
     * @memberof FunnelTimeToConvertChartType
     */
    'maxInterval'?: number;
}

export const FunnelTimeToConvertChartTypeTypeEnum = {
    TimeToConvert: 'timeToConvert'
} as const;

export type FunnelTimeToConvertChartTypeTypeEnum = typeof FunnelTimeToConvertChartTypeTypeEnum[keyof typeof FunnelTimeToConvertChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface GroupRecord
 */
export interface GroupRecord {
    /**
     * 
     * @type {number}
     * @memberof GroupRecord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GroupRecord
     */
    'strId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRecord
     */
    'group': string;
    /**
     * map of group property name and property value pairs
     * @type {{ [key: string]: Value; }}
     * @memberof GroupRecord
     */
    'properties': { [key: string]: Value; };
}
/**
 * 
 * @export
 * @interface GroupRecordsList200Response
 */
export interface GroupRecordsList200Response {
    /**
     * 
     * @type {Array<GroupRecord>}
     * @memberof GroupRecordsList200Response
     */
    'data'?: Array<GroupRecord>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof GroupRecordsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * request group records sorted by time of creation
 * @export
 * @interface GroupRecordsListRequest
 */
export interface GroupRecordsListRequest {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof GroupRecordsListRequest
     */
    'time': EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organization.
     * @type {string}
     * @memberof GroupRecordsListRequest
     */
    'group': string;
    /**
     * 
     * @type {string}
     * @memberof GroupRecordsListRequest
     */
    'searchTerm'?: string;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof GroupRecordsListRequest
     */
    'segments'?: Array<EventSegmentationSegment>;
    /**
     * 
     * @type {EventGroupedFilters}
     * @memberof GroupRecordsListRequest
     */
    'filters'?: EventGroupedFilters;
}
/**
 * see https://datatracker.ietf.org/doc/html/rfc7519
 * @export
 * @interface JWTToken
 */
export interface JWTToken {
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'accountId': number;
    /**
     * 
     * @type {string}
     * @memberof JWTToken
     */
    'iss': JWTTokenIssEnum;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'nbf': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'iat': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'jti': number;
}

export const JWTTokenIssEnum = {
    Optiprism: 'optiprism'
} as const;

export type JWTTokenIssEnum = typeof JWTTokenIssEnum[keyof typeof JWTTokenIssEnum];

/**
 * 
 * @export
 * @interface ListCustomPropertiesResponse
 */
export interface ListCustomPropertiesResponse {
    /**
     * 
     * @type {Array<CustomProperty>}
     * @memberof ListCustomPropertiesResponse
     */
    'events'?: Array<CustomProperty>;
}
/**
 * 
 * @export
 * @interface ListGroupRecordsResponse
 */
export interface ListGroupRecordsResponse {
    /**
     * 
     * @type {Array<GroupRecord>}
     * @memberof ListGroupRecordsResponse
     */
    'data'?: Array<GroupRecord>;
}
/**
 * 
 * @export
 * @interface ListPropertiesResponse
 */
export interface ListPropertiesResponse {
    /**
     * 
     * @type {Array<Property>}
     * @memberof ListPropertiesResponse
     */
    'data'?: Array<Property>;
}
/**
 * 
 * @export
 * @interface ListPropertyValuesRequest
 */
export interface ListPropertyValuesRequest {
    /**
     * 
     * @type {string}
     * @memberof ListPropertyValuesRequest
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListPropertyValuesRequest
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof ListPropertyValuesRequest
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {string}
     * @memberof ListPropertyValuesRequest
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListPropertyValuesRequest
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof ListPropertyValuesRequest
     */
    'eventType': EventType;
    /**
     * 
     * @type {PropertyValuesRequestFilter}
     * @memberof ListPropertyValuesRequest
     */
    'filter'?: PropertyValuesRequestFilter;
}


/**
 * 
 * @export
 * @interface ListPropertyValuesResponse
 */
export interface ListPropertyValuesResponse {
    /**
     * 
     * @type {Array<Value>}
     * @memberof ListPropertyValuesResponse
     */
    'data'?: Array<Value>;
}
/**
 * list response metadata
 * @export
 * @interface ListResponseMetadata
 */
export interface ListResponseMetadata {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof ListResponseMetadata
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface ListResponseMetadataMeta
 */
export interface ListResponseMetadataMeta {
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'prev'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMetadataMeta
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    'users'?: Array<number>;
}
/**
 * User profile
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {number}
     * @memberof Profile
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'createdBy': number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'updatedBy': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'sessionDurationSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'sdkToken': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'eventsCount': number;
}
/**
 * 
 * @export
 * @interface ProjectsList200Response
 */
export interface ProjectsList200Response {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof ProjectsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectsList200Response
     */
    'data'?: Array<Project>;
}
/**
 * Property defines event or user property. For example, event \"Buy product\" may contains next properties like \"Product name\" and \"Price.\" 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * property unique id
     * @type {number}
     * @memberof Property
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Property
     */
    'createdAt'?: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Property
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Property
     */
    'createdBy'?: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Property
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Property
     */
    'projectId': number;
    /**
     * list of id of events which use this property
     * @type {Array<number>}
     * @memberof Property
     */
    'events'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Property
     */
    'tags'?: Array<string>;
    /**
     * property name. Must be unique
     * @type {string}
     * @memberof Property
     */
    'name': string;
    /**
     * property name to display. If empty then name is used.
     * @type {string}
     * @memberof Property
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Property
     */
    'description'?: string;
    /**
     * 
     * @type {DataType}
     * @memberof Property
     */
    'dataType': DataType;
    /**
     * 
     * @type {PropertyStatus}
     * @memberof Property
     */
    'status': PropertyStatus;
    /**
     * the property is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Property
     */
    'isSystem': boolean;
    /**
     * nullable property might contains null value
     * @type {boolean}
     * @memberof Property
     */
    'nullable': boolean;
    /**
     * array property might contents multiple values
     * @type {boolean}
     * @memberof Property
     */
    'isArray': boolean;
    /**
     * dictionary can efficiently packs strings provided that cardinality will be relatively log (16bits is a reasonable maximum)
     * @type {boolean}
     * @memberof Property
     */
    'isDictionary': boolean;
    /**
     * 
     * @type {DictionaryDataType}
     * @memberof Property
     */
    'dictionaryType'?: DictionaryDataType;
}


/**
 * operation
 * @export
 * @enum {string}
 */

export const PropertyFilterOperation = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    True: 'true',
    False: 'false',
    Exists: 'exists',
    Empty: 'empty',
    Regex: 'regex',
    NotRegex: 'notRegex',
    Like: 'like',
    NotLike: 'notLike'
} as const;

export type PropertyFilterOperation = typeof PropertyFilterOperation[keyof typeof PropertyFilterOperation];


/**
 * reference to a property by id or name, depends on property type
 * @export
 * @interface PropertyRef
 */
export interface PropertyRef {
    /**
     * 
     * @type {string}
     * @memberof PropertyRef
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PropertyRef
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof PropertyRef
     */
    'propertyType': PropertyType;
}


/**
 * property status
 * @export
 * @enum {string}
 */

export const PropertyStatus = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type PropertyStatus = typeof PropertyStatus[keyof typeof PropertyStatus];


/**
 * possible property type
 * @export
 * @enum {string}
 */

export const PropertyType = {
    Event: 'event',
    User: 'user',
    Custom: 'custom',
    System: 'system'
} as const;

export type PropertyType = typeof PropertyType[keyof typeof PropertyType];


/**
 * 
 * @export
 * @interface PropertyValuesList200Response
 */
export interface PropertyValuesList200Response {
    /**
     * 
     * @type {Array<Value>}
     * @memberof PropertyValuesList200Response
     */
    'data'?: Array<Value>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof PropertyValuesList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface PropertyValuesRequestFilter
 */
export interface PropertyValuesRequestFilter {
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof PropertyValuesRequestFilter
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {Array<Value>}
     * @memberof PropertyValuesRequestFilter
     */
    'value': Array<Value>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const QueryAggregate = {
    Sum: 'sum',
    Avg: 'avg',
    Median: 'median',
    Count: 'count',
    Min: 'min',
    Max: 'max',
    DistinctCount: 'distinctCount',
    Percentile25: 'percentile25',
    Percentile75: 'percentile75',
    Percentile90: 'percentile90',
    Percentile99: 'percentile99'
} as const;

export type QueryAggregate = typeof QueryAggregate[keyof typeof QueryAggregate];


/**
 * 
 * @export
 * @enum {string}
 */

export const QueryAggregatePerGroup = {
    Sum: 'sum',
    Avg: 'avg',
    Median: 'median',
    Count: 'count',
    Min: 'min',
    Max: 'max',
    DistinctCount: 'distinctCount',
    Percentile25: 'percentile25',
    Percentile75: 'percentile75',
    Percentile90: 'percentile90',
    Percentile99: 'percentile99'
} as const;

export type QueryAggregatePerGroup = typeof QueryAggregatePerGroup[keyof typeof QueryAggregatePerGroup];


/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregateProperty
 */
export interface QueryAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryAggregateProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof QueryAggregateProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'type': QueryAggregatePropertyTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregateProperty
     */
    'aggregate': QueryAggregate;
}

export const QueryAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type QueryAggregatePropertyTypeEnum = typeof QueryAggregatePropertyTypeEnum[keyof typeof QueryAggregatePropertyTypeEnum];

/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregatePropertyPerGroup
 */
export interface QueryAggregatePropertyPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyType}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'type': QueryAggregatePropertyPerGroupTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregate': QueryAggregate;
    /**
     * 
     * @type {QueryAggregatePerGroup}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregatePerGroup': QueryAggregatePerGroup;
}

export const QueryAggregatePropertyPerGroupTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupTypeEnum = typeof QueryAggregatePropertyPerGroupTypeEnum[keyof typeof QueryAggregatePropertyPerGroupTypeEnum];

/**
 * event count aggregate by group
 * @export
 * @interface QueryCountPerGroup
 */
export interface QueryCountPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryCountPerGroup
     */
    'type': QueryCountPerGroupTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryCountPerGroup
     */
    'aggregate': QueryAggregate;
}

export const QueryCountPerGroupTypeEnum = {
    CountPerGroup: 'countPerGroup'
} as const;

export type QueryCountPerGroupTypeEnum = typeof QueryCountPerGroupTypeEnum[keyof typeof QueryCountPerGroupTypeEnum];

/**
 * apply formula
 * @export
 * @interface QueryFormula
 */
export interface QueryFormula {
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    'type': QueryFormulaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    'formula': string;
}

export const QueryFormulaTypeEnum = {
    Formula: 'formula'
} as const;

export type QueryFormulaTypeEnum = typeof QueryFormulaTypeEnum[keyof typeof QueryFormulaTypeEnum];

/**
 * simple query without any additional arguments
 * @export
 * @interface QuerySimple
 */
export interface QuerySimple {
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    'type': QuerySimpleTypeEnum;
}

export const QuerySimpleTypeEnum = {
    CountEvents: 'countEvents',
    CountUniqueGroups: 'countUniqueGroups',
    DailyActiveGroups: 'dailyActiveGroups',
    WeeklyActiveGroups: 'weeklyActiveGroups',
    MonthlyActiveGroups: 'monthlyActiveGroups'
} as const;

export type QuerySimpleTypeEnum = typeof QuerySimpleTypeEnum[keyof typeof QuerySimpleTypeEnum];

/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * report unique id
     * @type {number}
     * @memberof Report
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Report
     */
    'createdAt'?: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Report
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Report
     */
    'createdBy'?: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Report
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Report
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'name': string;
    /**
     * description
     * @type {string}
     * @memberof Report
     */
    'description'?: string;
    /**
     * 
     * @type {ReportType}
     * @memberof Report
     */
    'type': ReportType;
    /**
     * 
     * @type {ReportQuery}
     * @memberof Report
     */
    'query': ReportQuery;
}


/**
 * @type ReportQuery
 * @export
 */
export type ReportQuery = EventSegmentation | FunnelQuery;

/**
 * report type
 * @export
 * @enum {string}
 */

export const ReportType = {
    EventSegmentation: 'eventSegmentation',
    Funnel: 'funnel'
} as const;

export type ReportType = typeof ReportType[keyof typeof ReportType];


/**
 * 
 * @export
 * @interface ReportsList200Response
 */
export interface ReportsList200Response {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof ReportsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
    /**
     * 
     * @type {Array<Report>}
     * @memberof ReportsList200Response
     */
    'data'?: Array<Report>;
}
/**
 * did event condition
 * @export
 * @interface SegmentConditionDidEvent
 */
export interface SegmentConditionDidEvent {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionDidEvent
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventType}
     * @memberof SegmentConditionDidEvent
     */
    'eventType': EventType;
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'type': SegmentConditionDidEventTypeEnum;
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {SegmentConditionDidEventAllOfAggregate}
     * @memberof SegmentConditionDidEvent
     */
    'aggregate': SegmentConditionDidEventAllOfAggregate;
}

export const SegmentConditionDidEventTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventTypeEnum = typeof SegmentConditionDidEventTypeEnum[keyof typeof SegmentConditionDidEventTypeEnum];

/**
 * @type SegmentConditionDidEventAllOfAggregate
 * @export
 */
export type SegmentConditionDidEventAllOfAggregate = DidEventAggregateProperty | DidEventCount | DidEventHistoricalCount | DidEventRelativeCount;

/**
 * 
 * @export
 * @interface SegmentConditionFunnel
 */
export interface SegmentConditionFunnel {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionFunnel
     */
    'type': SegmentConditionFunnelTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionFunnel
     */
    'last'?: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof SegmentConditionFunnel
     */
    'bucket'?: TimeUnit;
}

export const SegmentConditionFunnelTypeEnum = {
    Funnel: 'funnel'
} as const;

export type SegmentConditionFunnelTypeEnum = typeof SegmentConditionFunnelTypeEnum[keyof typeof SegmentConditionFunnelTypeEnum];

/**
 * check whether the user had a property with a value
 * @export
 * @interface SegmentConditionHadPropertyValue
 */
export interface SegmentConditionHadPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'type': SegmentConditionHadPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHadPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHadPropertyValue
     */
    'value'?: Array<Value>;
    /**
     * 
     * @type {SegmentConditionHadPropertyValueTime}
     * @memberof SegmentConditionHadPropertyValue
     */
    'time': SegmentConditionHadPropertyValueTime;
}

export const SegmentConditionHadPropertyValueTypeEnum = {
    HadPropertyValue: 'hadPropertyValue'
} as const;

export type SegmentConditionHadPropertyValueTypeEnum = typeof SegmentConditionHadPropertyValueTypeEnum[keyof typeof SegmentConditionHadPropertyValueTypeEnum];

/**
 * @type SegmentConditionHadPropertyValueTime
 * time frame
 * @export
 */
export type SegmentConditionHadPropertyValueTime = TimeBetween | TimeLast | TimeWindowEach;

/**
 * check whether the user currently has a property with a value
 * @export
 * @interface SegmentConditionHasPropertyValue
 */
export interface SegmentConditionHasPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'type': SegmentConditionHasPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHasPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHasPropertyValue
     */
    'value'?: Array<Value>;
}

export const SegmentConditionHasPropertyValueTypeEnum = {
    HasPropertyValue: 'hasPropertyValue'
} as const;

export type SegmentConditionHasPropertyValueTypeEnum = typeof SegmentConditionHasPropertyValueTypeEnum[keyof typeof SegmentConditionHasPropertyValueTypeEnum];

/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'passwordRepeat': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'lastName'?: string;
}
/**
 * time spent after the first use of event. Use in segmentation
 * @export
 * @interface TimeAfterFirstUse
 */
export interface TimeAfterFirstUse {
    /**
     * 
     * @type {string}
     * @memberof TimeAfterFirstUse
     */
    'type': TimeAfterFirstUseTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeAfterFirstUse
     */
    'within': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeAfterFirstUse
     */
    'unit': TimeUnit;
}

export const TimeAfterFirstUseTypeEnum = {
    AfterFirstUse: 'afterFirstUse'
} as const;

export type TimeAfterFirstUseTypeEnum = typeof TimeAfterFirstUseTypeEnum[keyof typeof TimeAfterFirstUseTypeEnum];

/**
 * time range between fixed values
 * @export
 * @interface TimeBetween
 */
export interface TimeBetween {
    /**
     * 
     * @type {string}
     * @memberof TimeBetween
     */
    'type': TimeBetweenTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeBetween
     */
    'from': string;
    /**
     * end date
     * @type {string}
     * @memberof TimeBetween
     */
    'to': string;
}

export const TimeBetweenTypeEnum = {
    Between: 'between'
} as const;

export type TimeBetweenTypeEnum = typeof TimeBetweenTypeEnum[keyof typeof TimeBetweenTypeEnum];

/**
 * time range between fixed value and current time
 * @export
 * @interface TimeFrom
 */
export interface TimeFrom {
    /**
     * 
     * @type {string}
     * @memberof TimeFrom
     */
    'type': TimeFromTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeFrom
     */
    'from': string;
}

export const TimeFromTypeEnum = {
    From: 'from'
} as const;

export type TimeFromTypeEnum = typeof TimeFromTypeEnum[keyof typeof TimeFromTypeEnum];

/**
 * take last N days/weeks
 * @export
 * @interface TimeLast
 */
export interface TimeLast {
    /**
     * 
     * @type {string}
     * @memberof TimeLast
     */
    'type': TimeLastTypeEnum;
    /**
     * Last days/weeks
     * @type {number}
     * @memberof TimeLast
     */
    'last': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeLast
     */
    'unit': TimeUnit;
}

export const TimeLastTypeEnum = {
    Last: 'last'
} as const;

export type TimeLastTypeEnum = typeof TimeLastTypeEnum[keyof typeof TimeLastTypeEnum];

/**
 * time unit
 * @export
 * @enum {string}
 */

export const TimeUnit = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type TimeUnit = typeof TimeUnit[keyof typeof TimeUnit];


/**
 * time unit with session
 * @export
 * @enum {string}
 */

export const TimeUnitWithSession = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year',
    Session: 'session'
} as const;

export type TimeUnitWithSession = typeof TimeUnitWithSession[keyof typeof TimeUnitWithSession];


/**
 * window operation for segmentation. Tells that event should be triggered each timeunit (each day, for instance) {   \"time\": {     \"type\": \"windowEach\",     \"unit\":\"day\"   } } 
 * @export
 * @interface TimeWindowEach
 */
export interface TimeWindowEach {
    /**
     * 
     * @type {string}
     * @memberof TimeWindowEach
     */
    'type': TimeWindowEachTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeWindowEach
     */
    'unit': TimeUnit;
}

export const TimeWindowEachTypeEnum = {
    WindowEach: 'windowEach'
} as const;

export type TimeWindowEachTypeEnum = typeof TimeWindowEachTypeEnum[keyof typeof TimeWindowEachTypeEnum];

/**
 * 
 * @export
 * @interface TokensResponse
 */
export interface TokensResponse {
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'csrfToken'?: string;
}
/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties. 
 * @export
 * @interface UpdateCustomEventRequest
 */
export interface UpdateCustomEventRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CustomEventStatus}
     * @memberof UpdateCustomEventRequest
     */
    'status'?: CustomEventStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCustomEventRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof UpdateCustomEventRequest
     */
    'events': Array<CustomEventEvent>;
}


/**
 * 
 * @export
 * @interface UpdateDashboardRequest
 */
export interface UpdateDashboardRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateDashboardRequest
     */
    'tags'?: Array<string>;
    /**
     * dashboard name
     * @type {string}
     * @memberof UpdateDashboardRequest
     */
    'name'?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateDashboardRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DashboardPanel>}
     * @memberof UpdateDashboardRequest
     */
    'panels'?: Array<DashboardPanel>;
}
/**
 * Update event request
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof UpdateEventRequest
     */
    'status'?: EventStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateEventRequest
     */
    'tags'?: Array<string>;
}


/**
 * 
 * @export
 * @interface UpdateGroupRecordRequest
 */
export interface UpdateGroupRecordRequest {
    /**
     * map of group property name and property value pairs
     * @type {{ [key: string]: Value; }}
     * @memberof UpdateGroupRecordRequest
     */
    'properties': { [key: string]: Value; };
}
/**
 * 
 * @export
 * @interface UpdateProfileEmailRequest
 */
export interface UpdateProfileEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileEmailRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileEmailRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateProfileNameRequest
 */
export interface UpdateProfileNameRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileNameRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateProfilePasswordRequest
 */
export interface UpdateProfilePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfilePasswordRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfilePasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    'sessionDurationSeconds'?: number;
}
/**
 * Propetty update
 * @export
 * @interface UpdatePropertyRequest
 */
export interface UpdatePropertyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PropertyStatus}
     * @memberof UpdatePropertyRequest
     */
    'status'?: PropertyStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePropertyRequest
     */
    'tags'?: Array<string>;
}


/**
 * 
 * @export
 * @interface UpdateReportRequest
 */
export interface UpdateReportRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateReportRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateReportRequest
     */
    'name'?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateReportRequest
     */
    'description'?: string;
    /**
     * 
     * @type {ReportType}
     * @memberof UpdateReportRequest
     */
    'type'?: ReportType;
    /**
     * 
     * @type {ReportQuery}
     * @memberof UpdateReportRequest
     */
    'query'?: ReportQuery;
}


/**
 * 
 * @export
 * @interface UserPropertiesList200Response
 */
export interface UserPropertiesList200Response {
    /**
     * 
     * @type {Array<Property>}
     * @memberof UserPropertiesList200Response
     */
    'data'?: Array<Property>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof UserPropertiesList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * @type Value
 * value
 * @export
 */
export type Value = boolean | number | string;


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Basic login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicLogin: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('basicLogin', 'loginRequest', loginRequest)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Basic signup
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicSignup: async (signupRequest: SignupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('basicSignup', 'signupRequest', signupRequest)
            const localVarPath = `/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Basic login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basicLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basicLogin(loginRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.basicLogin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Basic signup
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basicSignup(signupRequest: SignupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basicSignup(signupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.basicSignup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.refreshToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Basic login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicLogin(loginRequest: LoginRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.basicLogin(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Basic signup
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicSignup(signupRequest: SignupRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.basicSignup(signupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.refreshToken(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Basic login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public basicLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).basicLogin(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Basic signup
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public basicSignup(signupRequest: SignupRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).basicSignup(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomEventsApi - axios parameter creator
 * @export
 */
export const CustomEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: async (projectId: number, createCustomEventRequest: CreateCustomEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCustomEvent', 'projectId', projectId)
            // verify required parameter 'createCustomEventRequest' is not null or undefined
            assertParamExists('createCustomEvent', 'createCustomEventRequest', createCustomEventRequest)
            const localVarPath = `/v1/projects/{projectId}/schema/custom-events`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customEventsList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/schema/custom-events`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomEvent: async (projectId: number, eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'eventId', eventId)
            const localVarPath = `/v1/projects/{projectId}/schema/custom-events/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEvent: async (projectId: number, eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCustomEvent', 'eventId', eventId)
            const localVarPath = `/v1/projects/{projectId}/schema/custom-events/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent: async (projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCustomEvent', 'eventId', eventId)
            // verify required parameter 'updateCustomEventRequest' is not null or undefined
            assertParamExists('updateCustomEvent', 'updateCustomEventRequest', updateCustomEventRequest)
            const localVarPath = `/v1/projects/{projectId}/schema/custom-events/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomEventsApi - functional programming interface
 * @export
 */
export const CustomEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomEvent(projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomEvent(projectId, createCustomEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CustomEventsApi.createCustomEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customEventsList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEventsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customEventsList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CustomEventsApi.customEventsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomEvent(projectId: number, eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomEvent(projectId, eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CustomEventsApi.deleteCustomEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomEvent(projectId: number, eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomEvent(projectId, eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CustomEventsApi.getCustomEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomEvent(projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomEvent(projectId, eventId, updateCustomEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CustomEventsApi.updateCustomEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CustomEventsApi - factory interface
 * @export
 */
export const CustomEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent(projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.createCustomEvent(projectId, createCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList(projectId: number, options?: any): AxiosPromise<CustomEventsList200Response> {
            return localVarFp.customEventsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomEvent(projectId: number, eventId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomEvent(projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEvent(projectId: number, eventId: number, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.getCustomEvent(projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent(projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.updateCustomEvent(projectId, eventId, updateCustomEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomEventsApi - object-oriented interface
 * @export
 * @class CustomEventsApi
 * @extends {BaseAPI}
 */
export class CustomEventsApi extends BaseAPI {
    /**
     * 
     * @summary Create custom event
     * @param {number} projectId 
     * @param {CreateCustomEventRequest} createCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomEventsApi
     */
    public createCustomEvent(projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: RawAxiosRequestConfig) {
        return CustomEventsApiFp(this.configuration).createCustomEvent(projectId, createCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Custom events list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomEventsApi
     */
    public customEventsList(projectId: number, options?: RawAxiosRequestConfig) {
        return CustomEventsApiFp(this.configuration).customEventsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete custom event
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomEventsApi
     */
    public deleteCustomEvent(projectId: number, eventId: number, options?: RawAxiosRequestConfig) {
        return CustomEventsApiFp(this.configuration).deleteCustomEvent(projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get custom event
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomEventsApi
     */
    public getCustomEvent(projectId: number, eventId: number, options?: RawAxiosRequestConfig) {
        return CustomEventsApiFp(this.configuration).getCustomEvent(projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update custom event
     * @param {number} projectId 
     * @param {string} eventId Custom Event ID
     * @param {UpdateCustomEventRequest} updateCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomEventsApi
     */
    public updateCustomEvent(projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: RawAxiosRequestConfig) {
        return CustomEventsApiFp(this.configuration).updateCustomEvent(projectId, eventId, updateCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {number} projectId 
         * @param {CreateDashboardRequest} createDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard: async (projectId: number, createDashboardRequest: CreateDashboardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDashboard', 'projectId', projectId)
            // verify required parameter 'createDashboardRequest' is not null or undefined
            assertParamExists('createDashboard', 'createDashboardRequest', createDashboardRequest)
            const localVarPath = `/v1/projects/{projectId}/dashboards`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDashboardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dashboards list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dashboardsList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/dashboards`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard: async (projectId: number, dashboardId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteDashboard', 'projectId', projectId)
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('deleteDashboard', 'dashboardId', dashboardId)
            const localVarPath = `/v1/projects/{projectId}/dashboards/{dashboardId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (projectId: number, dashboardId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDashboard', 'projectId', projectId)
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('getDashboard', 'dashboardId', dashboardId)
            const localVarPath = `/v1/projects/{projectId}/dashboards/{dashboardId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {UpdateDashboardRequest} updateDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard: async (projectId: number, dashboardId: number, updateDashboardRequest: UpdateDashboardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDashboard', 'projectId', projectId)
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('updateDashboard', 'dashboardId', dashboardId)
            // verify required parameter 'updateDashboardRequest' is not null or undefined
            assertParamExists('updateDashboard', 'updateDashboardRequest', updateDashboardRequest)
            const localVarPath = `/v1/projects/{projectId}/dashboards/{dashboardId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDashboardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {number} projectId 
         * @param {CreateDashboardRequest} createDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboard(projectId: number, createDashboardRequest: CreateDashboardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboard(projectId, createDashboardRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DashboardsApi.createDashboard']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Dashboards list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardsList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardsList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DashboardsApi.dashboardsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboard(projectId: number, dashboardId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboard(projectId, dashboardId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DashboardsApi.deleteDashboard']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(projectId: number, dashboardId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(projectId, dashboardId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DashboardsApi.getDashboard']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {UpdateDashboardRequest} updateDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDashboard(projectId: number, dashboardId: number, updateDashboardRequest: UpdateDashboardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboard(projectId, dashboardId, updateDashboardRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DashboardsApi.updateDashboard']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {number} projectId 
         * @param {CreateDashboardRequest} createDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(projectId: number, createDashboardRequest: CreateDashboardRequest, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.createDashboard(projectId, createDashboardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dashboards list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsList(projectId: number, options?: any): AxiosPromise<DashboardsList200Response> {
            return localVarFp.dashboardsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(projectId: number, dashboardId: number, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.deleteDashboard(projectId, dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(projectId: number, dashboardId: number, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.getDashboard(projectId, dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update dashboard
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {UpdateDashboardRequest} updateDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(projectId: number, dashboardId: number, updateDashboardRequest: UpdateDashboardRequest, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.updateDashboard(projectId, dashboardId, updateDashboardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Create dashboard
     * @param {number} projectId 
     * @param {CreateDashboardRequest} createDashboardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public createDashboard(projectId: number, createDashboardRequest: CreateDashboardRequest, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).createDashboard(projectId, createDashboardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dashboards list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsList(projectId: number, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).dashboardsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete dashboard
     * @param {number} projectId 
     * @param {number} dashboardId Dashboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboard(projectId: number, dashboardId: number, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).deleteDashboard(projectId, dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard
     * @param {number} projectId 
     * @param {number} dashboardId Dashboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboard(projectId: number, dashboardId: number, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).getDashboard(projectId, dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update dashboard
     * @param {number} projectId 
     * @param {number} dashboardId Dashboard ID
     * @param {UpdateDashboardRequest} updateDashboardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public updateDashboard(projectId: number, dashboardId: number, updateDashboardRequest: UpdateDashboardRequest, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).updateDashboard(projectId, dashboardId, updateDashboardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventPropertiesApi - axios parameter creator
 * @export
 */
export const EventPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPropertiesList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/schema/event-properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventProperty: async (projectId: number, propertyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEventProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getEventProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/projects/{projectId}/schema/event-properties/{propertyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update event property
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventProperty: async (projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEventProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateEventProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateEventProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/projects/{projectId}/schema/event-properties/{propertyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventPropertiesApi - functional programming interface
 * @export
 */
export const EventPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventPropertiesList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventPropertiesList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventPropertiesApi.eventPropertiesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get event property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventProperty(projectId: number, propertyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventProperty(projectId, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventPropertiesApi.getEventProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update event property
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventProperty(projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventProperty(projectId, propertyId, updatePropertyRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventPropertiesApi.updateEventProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EventPropertiesApi - factory interface
 * @export
 */
export const EventPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventPropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Event properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPropertiesList(projectId: number, options?: any): AxiosPromise<UserPropertiesList200Response> {
            return localVarFp.eventPropertiesList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventProperty(projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getEventProperty(projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update event property
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventProperty(projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateEventProperty(projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventPropertiesApi - object-oriented interface
 * @export
 * @class EventPropertiesApi
 * @extends {BaseAPI}
 */
export class EventPropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Event properties list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventPropertiesApi
     */
    public eventPropertiesList(projectId: number, options?: RawAxiosRequestConfig) {
        return EventPropertiesApiFp(this.configuration).eventPropertiesList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event property
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventPropertiesApi
     */
    public getEventProperty(projectId: number, propertyId: number, options?: RawAxiosRequestConfig) {
        return EventPropertiesApiFp(this.configuration).getEventProperty(projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update event property
     * @param {number} projectId 
     * @param {string} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventPropertiesApi
     */
    public updateEventProperty(projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: RawAxiosRequestConfig) {
        return EventPropertiesApiFp(this.configuration).updateEventProperty(projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventRecordsApi - axios parameter creator
 * @export
 */
export const EventRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get event records
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventRecordsList: async (projectId: number, eventRecordsListRequest: EventRecordsListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventRecordsList', 'projectId', projectId)
            // verify required parameter 'eventRecordsListRequest' is not null or undefined
            assertParamExists('eventRecordsList', 'eventRecordsListRequest', eventRecordsListRequest)
            const localVarPath = `/v1/projects/{projectId}/event-records/search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventRecordsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event record
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRecord: async (projectId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEventRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventRecord', 'id', id)
            const localVarPath = `/v1/projects/{projectId}/event-records/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventRecordsApi - functional programming interface
 * @export
 */
export const EventRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get event records
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventRecordsList(projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventRecordsList(projectId, eventRecordsListRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventRecordsApi.eventRecordsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get event record
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventRecord(projectId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventRecord(projectId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventRecordsApi.getEventRecord']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EventRecordsApi - factory interface
 * @export
 */
export const EventRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventRecordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get event records
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventRecordsList(projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.eventRecordsList(projectId, eventRecordsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event record
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRecord(projectId: number, id: number, options?: any): AxiosPromise<EventRecord> {
            return localVarFp.getEventRecord(projectId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventRecordsApi - object-oriented interface
 * @export
 * @class EventRecordsApi
 * @extends {BaseAPI}
 */
export class EventRecordsApi extends BaseAPI {
    /**
     * 
     * @summary Get event records
     * @param {number} projectId 
     * @param {EventRecordsListRequest} eventRecordsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventRecordsApi
     */
    public eventRecordsList(projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: RawAxiosRequestConfig) {
        return EventRecordsApiFp(this.configuration).eventRecordsList(projectId, eventRecordsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event record
     * @param {number} projectId 
     * @param {number} id Event Record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventRecordsApi
     */
    public getEventRecord(projectId: number, id: number, options?: RawAxiosRequestConfig) {
        return EventRecordsApiFp(this.configuration).getEventRecord(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Events list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventsList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/schema/events`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (projectId: number, eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEvent', 'eventId', eventId)
            const localVarPath = `/v1/projects/{projectId}/schema/events/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update event
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'updateEventRequest' is not null or undefined
            assertParamExists('updateEvent', 'updateEventRequest', updateEventRequest)
            const localVarPath = `/v1/projects/{projectId}/schema/events/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Events list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.eventsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(projectId: number, eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(projectId, eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update event
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(projectId, eventId, updateEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Events list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(projectId: number, options?: any): AxiosPromise<EventsList200Response> {
            return localVarFp.eventsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(projectId: number, eventId: number, options?: any): AxiosPromise<Event> {
            return localVarFp.getEvent(projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update event
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<Event> {
            return localVarFp.updateEvent(projectId, eventId, updateEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Events list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsList(projectId: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(projectId: number, eventId: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update event
     * @param {number} projectId 
     * @param {string} eventId Event ID
     * @param {UpdateEventRequest} updateEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(projectId, eventId, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupRecordsApi - axios parameter creator
 * @export
 */
export const GroupRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRecord: async (projectId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getGroupRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupRecord', 'id', id)
            const localVarPath = `/v1/projects/{projectId}/group-records/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List group records
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRecordsList: async (projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('groupRecordsList', 'projectId', projectId)
            // verify required parameter 'groupRecordsListRequest' is not null or undefined
            assertParamExists('groupRecordsList', 'groupRecordsListRequest', groupRecordsListRequest)
            const localVarPath = `/v1/projects/{projectId}/group-records/search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRecordsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update group record
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRecord: async (projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateGroupRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroupRecord', 'id', id)
            // verify required parameter 'updateGroupRecordRequest' is not null or undefined
            assertParamExists('updateGroupRecord', 'updateGroupRecordRequest', updateGroupRecordRequest)
            const localVarPath = `/v1/projects/{projectId}/group-records/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupRecordsApi - functional programming interface
 * @export
 */
export const GroupRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRecord(projectId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRecord(projectId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupRecordsApi.getGroupRecord']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List group records
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRecordsList(projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecordsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupRecordsList(projectId, groupRecordsListRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupRecordsApi.groupRecordsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update group record
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupRecord(projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupRecord(projectId, id, updateGroupRecordRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupRecordsApi.updateGroupRecord']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GroupRecordsApi - factory interface
 * @export
 */
export const GroupRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupRecordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRecord(projectId: number, id: number, options?: any): AxiosPromise<GroupRecord> {
            return localVarFp.getGroupRecord(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List group records
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRecordsList(projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: any): AxiosPromise<GroupRecordsList200Response> {
            return localVarFp.groupRecordsList(projectId, groupRecordsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update group record
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRecord(projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options?: any): AxiosPromise<GroupRecord> {
            return localVarFp.updateGroupRecord(projectId, id, updateGroupRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupRecordsApi - object-oriented interface
 * @export
 * @class GroupRecordsApi
 * @extends {BaseAPI}
 */
export class GroupRecordsApi extends BaseAPI {
    /**
     * 
     * @summary Get group record
     * @param {number} projectId 
     * @param {number} id Group Record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRecordsApi
     */
    public getGroupRecord(projectId: number, id: number, options?: RawAxiosRequestConfig) {
        return GroupRecordsApiFp(this.configuration).getGroupRecord(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List group records
     * @param {number} projectId 
     * @param {GroupRecordsListRequest} groupRecordsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRecordsApi
     */
    public groupRecordsList(projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: RawAxiosRequestConfig) {
        return GroupRecordsApiFp(this.configuration).groupRecordsList(projectId, groupRecordsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update group record
     * @param {number} projectId 
     * @param {number} id Group Record ID
     * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRecordsApi
     */
    public updateGroupRecord(projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options?: RawAxiosRequestConfig) {
        return GroupRecordsApiFp(this.configuration).updateGroupRecord(projectId, id, updateGroupRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email
         * @param {UpdateProfileEmailRequest} updateProfileEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileEmail: async (updateProfileEmailRequest: UpdateProfileEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileEmailRequest' is not null or undefined
            assertParamExists('updateProfileEmail', 'updateProfileEmailRequest', updateProfileEmailRequest)
            const localVarPath = `/v1/profile/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update name
         * @param {UpdateProfileNameRequest} updateProfileNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileName: async (updateProfileNameRequest: UpdateProfileNameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileNameRequest' is not null or undefined
            assertParamExists('updateProfileName', 'updateProfileNameRequest', updateProfileNameRequest)
            const localVarPath = `/v1/profile/name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {UpdateProfilePasswordRequest} updateProfilePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfilePassword: async (updateProfilePasswordRequest: UpdateProfilePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfilePasswordRequest' is not null or undefined
            assertParamExists('updateProfilePassword', 'updateProfilePasswordRequest', updateProfilePasswordRequest)
            const localVarPath = `/v1/profile/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfilePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileApi.getProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update email
         * @param {UpdateProfileEmailRequest} updateProfileEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileEmail(updateProfileEmailRequest: UpdateProfileEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileEmail(updateProfileEmailRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileApi.updateProfileEmail']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update name
         * @param {UpdateProfileNameRequest} updateProfileNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileName(updateProfileNameRequest: UpdateProfileNameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileName(updateProfileNameRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileApi.updateProfileName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {UpdateProfilePasswordRequest} updateProfilePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfilePassword(updateProfilePasswordRequest: UpdateProfilePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfilePassword(updateProfilePasswordRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileApi.updateProfilePassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Get profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any): AxiosPromise<Profile> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update email
         * @param {UpdateProfileEmailRequest} updateProfileEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileEmail(updateProfileEmailRequest: UpdateProfileEmailRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.updateProfileEmail(updateProfileEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update name
         * @param {UpdateProfileNameRequest} updateProfileNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileName(updateProfileNameRequest: UpdateProfileNameRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfileName(updateProfileNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update password
         * @param {UpdateProfilePasswordRequest} updateProfilePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfilePassword(updateProfilePasswordRequest: UpdateProfilePasswordRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.updateProfilePassword(updateProfilePasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @summary Get profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update email
     * @param {UpdateProfileEmailRequest} updateProfileEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileEmail(updateProfileEmailRequest: UpdateProfileEmailRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileEmail(updateProfileEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update name
     * @param {UpdateProfileNameRequest} updateProfileNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileName(updateProfileNameRequest: UpdateProfileNameRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileName(updateProfileNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update password
     * @param {UpdateProfilePasswordRequest} updateProfilePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfilePassword(updateProfilePasswordRequest: UpdateProfilePasswordRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfilePassword(updateProfilePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project
         * @param {CreateProjectRequest} createProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (createProjectRequest: CreateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectRequest' is not null or undefined
            assertParamExists('createProject', 'createProjectRequest', createProjectRequest)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        project: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('project', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Projects list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsList', 'projectId', projectId)
            const localVarPath = `/v1/projects`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project
         * @param {number} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: number, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('updateProject', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create project
         * @param {CreateProjectRequest} createProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(createProjectRequest: CreateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(createProjectRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.createProject']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.deleteProject']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async project(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.project(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.project']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Projects list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update project
         * @param {number} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: number, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, updateProjectRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.updateProject']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create project
         * @param {CreateProjectRequest} createProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(createProjectRequest: CreateProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.createProject(createProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: number, options?: any): AxiosPromise<Project> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        project(projectId: number, options?: any): AxiosPromise<Project> {
            return localVarFp.project(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Projects list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList(projectId: number, options?: any): AxiosPromise<ProjectsList200Response> {
            return localVarFp.projectsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project
         * @param {number} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: number, updateProjectRequest: UpdateProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.updateProject(projectId, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create project
     * @param {CreateProjectRequest} createProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(createProjectRequest: CreateProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(createProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectId: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public project(projectId: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).project(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Projects list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsList(projectId: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project
     * @param {number} projectId 
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(projectId: number, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(projectId, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/schema/custom-properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customPropertiesList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customPropertiesList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertiesApi.customPropertiesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList(projectId: number, options?: any): AxiosPromise<CustomPropertiesList200Response> {
            return localVarFp.customPropertiesList(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Event custom properties list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public customPropertiesList(projectId: number, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).customPropertiesList(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyValuesApi - axios parameter creator
 * @export
 */
export const PropertyValuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of property values
         * @param {number} projectId 
         * @param {ListPropertyValuesRequest} listPropertyValuesRequest property type and property id/name must be specified. Event is optional and  works as a filter for values 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList: async (projectId: number, listPropertyValuesRequest: ListPropertyValuesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('propertyValuesList', 'projectId', projectId)
            // verify required parameter 'listPropertyValuesRequest' is not null or undefined
            assertParamExists('propertyValuesList', 'listPropertyValuesRequest', listPropertyValuesRequest)
            const localVarPath = `/v1/projects/{projectId}/property-values`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listPropertyValuesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyValuesApi - functional programming interface
 * @export
 */
export const PropertyValuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyValuesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List of property values
         * @param {number} projectId 
         * @param {ListPropertyValuesRequest} listPropertyValuesRequest property type and property id/name must be specified. Event is optional and  works as a filter for values 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async propertyValuesList(projectId: number, listPropertyValuesRequest: ListPropertyValuesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyValuesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.propertyValuesList(projectId, listPropertyValuesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PropertyValuesApi.propertyValuesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PropertyValuesApi - factory interface
 * @export
 */
export const PropertyValuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyValuesApiFp(configuration)
    return {
        /**
         * 
         * @summary List of property values
         * @param {number} projectId 
         * @param {ListPropertyValuesRequest} listPropertyValuesRequest property type and property id/name must be specified. Event is optional and  works as a filter for values 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList(projectId: number, listPropertyValuesRequest: ListPropertyValuesRequest, options?: any): AxiosPromise<PropertyValuesList200Response> {
            return localVarFp.propertyValuesList(projectId, listPropertyValuesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyValuesApi - object-oriented interface
 * @export
 * @class PropertyValuesApi
 * @extends {BaseAPI}
 */
export class PropertyValuesApi extends BaseAPI {
    /**
     * 
     * @summary List of property values
     * @param {number} projectId 
     * @param {ListPropertyValuesRequest} listPropertyValuesRequest property type and property id/name must be specified. Event is optional and  works as a filter for values 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyValuesApi
     */
    public propertyValuesList(projectId: number, listPropertyValuesRequest: ListPropertyValuesRequest, options?: RawAxiosRequestConfig) {
        return PropertyValuesApiFp(this.configuration).propertyValuesList(projectId, listPropertyValuesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event segmentation query
         * @param {number} projectId 
         * @param {EventSegmentationQueryFormatEnum} format 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSegmentationQuery: async (projectId: number, format: EventSegmentationQueryFormatEnum, eventSegmentation?: EventSegmentation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventSegmentationQuery', 'projectId', projectId)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('eventSegmentationQuery', 'format', format)
            const localVarPath = `/v1/projects/{projectId}/queries/event-segmentation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSegmentation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Funnel query
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        funnelQuery: async (projectId: number, funnelQuery?: FunnelQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('funnelQuery', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/queries/funnel`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(funnelQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event segmentation query
         * @param {number} projectId 
         * @param {EventSegmentationQueryFormatEnum} format 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSegmentationQuery(projectId: number, format: EventSegmentationQueryFormatEnum, eventSegmentation?: EventSegmentation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSegmentationQuery(projectId, format, eventSegmentation, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QueryApi.eventSegmentationQuery']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Funnel query
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async funnelQuery(projectId: number, funnelQuery?: FunnelQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.funnelQuery(projectId, funnelQuery, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QueryApi.funnelQuery']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @summary Event segmentation query
         * @param {number} projectId 
         * @param {EventSegmentationQueryFormatEnum} format 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSegmentationQuery(projectId: number, format: EventSegmentationQueryFormatEnum, eventSegmentation?: EventSegmentation, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.eventSegmentationQuery(projectId, format, eventSegmentation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Funnel query
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        funnelQuery(projectId: number, funnelQuery?: FunnelQuery, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.funnelQuery(projectId, funnelQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Event segmentation query
     * @param {number} projectId 
     * @param {EventSegmentationQueryFormatEnum} format 
     * @param {EventSegmentation} [eventSegmentation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public eventSegmentationQuery(projectId: number, format: EventSegmentationQueryFormatEnum, eventSegmentation?: EventSegmentation, options?: RawAxiosRequestConfig) {
        return QueryApiFp(this.configuration).eventSegmentationQuery(projectId, format, eventSegmentation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Funnel query
     * @param {number} projectId 
     * @param {FunnelQuery} [funnelQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public funnelQuery(projectId: number, funnelQuery?: FunnelQuery, options?: RawAxiosRequestConfig) {
        return QueryApiFp(this.configuration).funnelQuery(projectId, funnelQuery, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EventSegmentationQueryFormatEnum = {
    Json: 'json',
    JsonCompact: 'jsonCompact'
} as const;
export type EventSegmentationQueryFormatEnum = typeof EventSegmentationQueryFormatEnum[keyof typeof EventSegmentationQueryFormatEnum];


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create report
         * @param {number} projectId 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (projectId: number, createReportRequest: CreateReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createReport', 'projectId', projectId)
            // verify required parameter 'createReportRequest' is not null or undefined
            assertParamExists('createReport', 'createReportRequest', createReportRequest)
            const localVarPath = `/v1/projects/{projectId}/reports`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (projectId: number, reportId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteReport', 'projectId', projectId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('deleteReport', 'reportId', reportId)
            const localVarPath = `/v1/projects/{projectId}/reports/{reportId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (projectId: number, reportId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getReport', 'projectId', projectId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/v1/projects/{projectId}/reports/{reportId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('reportsList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/reports`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {UpdateReportRequest} updateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport: async (projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateReport', 'projectId', projectId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('updateReport', 'reportId', reportId)
            // verify required parameter 'updateReportRequest' is not null or undefined
            assertParamExists('updateReport', 'updateReportRequest', updateReportRequest)
            const localVarPath = `/v1/projects/{projectId}/reports/{reportId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create report
         * @param {number} projectId 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(projectId: number, createReportRequest: CreateReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(projectId, createReportRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsApi.createReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(projectId: number, reportId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(projectId, reportId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsApi.deleteReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(projectId: number, reportId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(projectId, reportId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsApi.getReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reports list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsApi.reportsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {UpdateReportRequest} updateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReport(projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReport(projectId, reportId, updateReportRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReportsApi.updateReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create report
         * @param {number} projectId 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(projectId: number, createReportRequest: CreateReportRequest, options?: any): AxiosPromise<Report> {
            return localVarFp.createReport(projectId, createReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(projectId: number, reportId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReport(projectId, reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(projectId: number, reportId: number, options?: any): AxiosPromise<Report> {
            return localVarFp.getReport(projectId, reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsList(projectId: number, options?: any): AxiosPromise<ReportsList200Response> {
            return localVarFp.reportsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update report
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {UpdateReportRequest} updateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport(projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options?: any): AxiosPromise<Report> {
            return localVarFp.updateReport(projectId, reportId, updateReportRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Create report
     * @param {number} projectId 
     * @param {CreateReportRequest} createReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public createReport(projectId: number, createReportRequest: CreateReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).createReport(projectId, createReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete report
     * @param {number} projectId 
     * @param {number} reportId Report ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public deleteReport(projectId: number, reportId: number, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).deleteReport(projectId, reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get report
     * @param {number} projectId 
     * @param {number} reportId Report ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReport(projectId: number, reportId: number, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReport(projectId, reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsList(projectId: number, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update report
     * @param {number} projectId 
     * @param {number} reportId Report ID
     * @param {UpdateReportRequest} updateReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public updateReport(projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).updateReport(projectId, reportId, updateReportRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemPropertiesApi - axios parameter creator
 * @export
 */
export const SystemPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get system property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemProperty: async (projectId: number, propertyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSystemProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getSystemProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/projects/{projectId}/schema/system-properties/{propertyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary System properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPropertiesList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('systemPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/schema/system-properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemPropertiesApi - functional programming interface
 * @export
 */
export const SystemPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get system property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemProperty(projectId: number, propertyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemProperty(projectId, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemPropertiesApi.getSystemProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary System properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPropertiesList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPropertiesList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemPropertiesApi.systemPropertiesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SystemPropertiesApi - factory interface
 * @export
 */
export const SystemPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemPropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get system property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemProperty(projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getSystemProperty(projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary System properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPropertiesList(projectId: number, options?: any): AxiosPromise<UserPropertiesList200Response> {
            return localVarFp.systemPropertiesList(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemPropertiesApi - object-oriented interface
 * @export
 * @class SystemPropertiesApi
 * @extends {BaseAPI}
 */
export class SystemPropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Get system property
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPropertiesApi
     */
    public getSystemProperty(projectId: number, propertyId: number, options?: RawAxiosRequestConfig) {
        return SystemPropertiesApiFp(this.configuration).getSystemProperty(projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary System properties list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPropertiesApi
     */
    public systemPropertiesList(projectId: number, options?: RawAxiosRequestConfig) {
        return SystemPropertiesApiFp(this.configuration).systemPropertiesList(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPropertiesApi - axios parameter creator
 * @export
 */
export const UserPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProperty: async (projectId: number, propertyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getUserProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getUserProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/projects/{projectId}/schema/user-properties/{propertyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProperty: async (projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateUserProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateUserProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateUserProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/projects/{projectId}/schema/user-properties/{propertyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPropertiesList: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('userPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{projectId}/schema/user-properties`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPropertiesApi - functional programming interface
 * @export
 */
export const UserPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProperty(projectId: number, propertyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProperty(projectId, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertiesApi.getUserProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update user property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProperty(projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProperty(projectId, propertyId, updatePropertyRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertiesApi.updateUserProperty']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary User properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPropertiesList(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPropertiesList(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserPropertiesApi.userPropertiesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserPropertiesApi - factory interface
 * @export
 */
export const UserPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProperty(projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getUserProperty(projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user property
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProperty(projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateUserProperty(projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User properties list
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPropertiesList(projectId: number, options?: any): AxiosPromise<UserPropertiesList200Response> {
            return localVarFp.userPropertiesList(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPropertiesApi - object-oriented interface
 * @export
 * @class UserPropertiesApi
 * @extends {BaseAPI}
 */
export class UserPropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Get user property
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertiesApi
     */
    public getUserProperty(projectId: number, propertyId: number, options?: RawAxiosRequestConfig) {
        return UserPropertiesApiFp(this.configuration).getUserProperty(projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user property
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertiesApi
     */
    public updateUserProperty(projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: RawAxiosRequestConfig) {
        return UserPropertiesApiFp(this.configuration).updateUserProperty(projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User properties list
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPropertiesApi
     */
    public userPropertiesList(projectId: number, options?: RawAxiosRequestConfig) {
        return UserPropertiesApiFp(this.configuration).userPropertiesList(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



